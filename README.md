# Lernjournal

## 19. November 2024

### Was wir gemacht haben:
- Repository für unsere Java-Projekte eingerichtet
- Repository mit Miro verknüpft für Lehrerzugriff
- An zwei Java-Aufgaben gearbeitet:
  - Implementierung eines Notenrechners
  - Debugging-Übungen durchgeführt

### Was wir gelernt haben:
- Grundlegende Java-Konzepte:
  - Variablendeklaration und -typen
  - Grundlegende Syntax in Java
  - Erste Schritte mit Debugging
- Umgang mit Git/Repository-Management

## 26. November 2024

### Was wir gemacht haben:
- Erfolgreich Tests absolviert:
  - Test D1
  - Test A1
  - Test A2
- Weiter an laufendem Aufgaben gearbeteitet:
  - E1 Serie A

### Was wir gelernt haben:
- Anforderungsanalyse in der Softwareentwicklung:
  - Definition und Bedeutung von Anforderungen
  - Kriterien für gut formulierte Anforderungen:
    - Verständlichkeit
    - Widerspruchsfreiheit
    - Vollständigkeit
    - Prüfbarkeit
  - Klassifizierung von Anforderungen (MoSCoW-Prinzip):
    - Muss-Anforderungen
    - Soll-Anforderungen
    - Wunsch-Anforderungen
  - Verschiedene Strukturierungsmöglichkeiten:
    - Anforderungslisten
    - Use Cases
    - Aktivitätsdiagramme
  - Unterscheidung zwischen:
    - Funktionalen Anforderungen (Was soll das Programm tun?)
    - Nicht-funktionalen Anforderungen (Qualitätskriterien)

## 3. Dezember 2024
### Was wir gemacht haben:
- Erfolgreich Tests absolviert:
 - Test D2 (Java OOP Grundlagen) 
 - Test E2 (Java Fehlerbehandlung)
- Tieferes Verständnis der Fehlerbehandlung in Java
- Praktische Übungen zu Code-Review und Debugging

### Was wir gelernt haben:
- Fehlerarten in Java:
 - Syntaxfehler (Compilerfehler)
 - Laufzeitfehler
 - Logische Fehler

- Code-Review (C-R):
 - Führt zur deutlichen Reduktion von Fehlern
 - Verschiedene Techniken wie Walkthrough
 - Formale Prozesse und deren Dokumentation

- Debugging in Java:
 - Verwendung von Debugger-Tools
 - Schrittweise Programmausführung
 - Überprüfung von Variableninhalten
 - Erkennen und Beheben von Laufzeitfehlern

- Fehlermeldungen:
 - Unterscheidung zwischen Compiler- und Laufzeitfehlern
 - Interpretation von Fehlermeldungen 
 - Warnmeldungen und deren Bedeutung
 - Lokalisierung von Fehlern im Code

- Best Practices:
 - Systematische Fehlersuche
 - Dokumentation von gefundenen Fehlern
 - Implementierung von Gegenmaßnahmen
 - Präventive Maßnahmen zur Fehlervermeidung

## 10. Dezember 2024
### Was wir gemacht haben:
- Task A3 bearbeitet
- Task I3 angefangen
- EVA-Prinzip gelernt: Eingabe, Verarbeitung, Ausgabe sollten getrennt sein
- Code-Stil Regeln für die Schule (TBZ-IT) kennengelernt

### Was wir gelernt haben:
- Code sauber schreiben:
  - Mindestens 4 Zeichen einrücken
  - Gute Namen für Variablen wählen 
  - Klassen groß schreiben, Variablen klein
  - Code auf Englisch, Kommentare auf Deutsch

- EVA-Prinzip verstanden:
  - Eingabe separat am Anfang
  - Verarbeitung in der Mitte
  - Ausgabe am Ende
  - Macht den Code übersichtlicher
  - Einfacher zu warten und zu erweitern

- Mit IntelliJ gearbeitet:
  - Code automatisch formatieren lassen
  - Refactoring-Werkzeuge kennengelernt
  - Code aufräumen und kommentieren

 ## 17. Dezember 2024
### Was wir gemacht haben:
- Erweitertes Lagerverwaltungssystem entwickelt:
  - Grundstruktur mit EVA-Prinzip implementiert
  - Verschiedene Produkttypen (Elektronik, Lebensmittel) erstellt
  - Benutzerinteraktion über Konsolenmenü eingebaut
  - CRUD-Operationen (Create, Read, Update, Delete) implementiert

### Was wir gelernt haben:
- Objektorientierte Programmierung vertieft:
  - Abstrakte Klassen und Interfaces
  - Vererbungshierarchien erstellen
  - Polymorphismus in der Praxis anwenden
  - Enums für Statusverwaltung nutzen
  
- Fortgeschrittene Java-Konzepte:
  - Exception-Handling für Fehlerbehandlung
  - Scanner für Benutzereingaben
  - Stream API für Datenverarbeitung
  - Enum-Verwendung für Status-Management

- Softwarestrukturierung:
  - Code auf mehrere Dateien aufteilen
  - Klassenstrukturen planen
  - EVA-Prinzip praktisch umsetzen
  - Modulare Programmierung anwenden

- Best Practices:
  - Saubere Codeformatierung
  - Aussagekräftige Kommentare
  - Fehlerbehandlung implementieren
  - Benutzerfreundliche Menüführung

## 7. Januar 2025
### Was wir gemacht haben:
- Schachbrett-Programm in Java entwickelt:
  - Grundlegende Brettdarstellung mit Figuren implementiert
  - Bewegungsfunktion für Figuren erstellt
  - Array-Manipulation für Spielzüge umgesetzt
  - Visualisierung des Bretts in der Konsole realisiert
- Nach den Ferien Java-Grundlagen aufgefrischt
- Bugfixes am bestehenden Code durchgeführt

### Was wir gelernt haben:
- Zweidimensionale Arrays in Java:
  - Erstellung und Initialisierung
  - Zugriff auf Array-Elemente
  - Manipulation von Array-Inhalten
  - Traversierung mit verschachtelten Schleifen

- Methodenentwicklung:
  - Parameter übergabe und -verarbeitung
  - Implementierung von Bewegungslogik
  - Konsolenausgabe formatieren

- Debugging und Code-Verbesserung:
  - Fehlererkennung in bestehendem Code
  - Systematische Fehlerkorrektur
  - Codeoptimierung nach den Ferien

- Best Practices wiederholt:
  - Klare Methodennamen (z.B. `printBoard`, `move`)
  - Saubere Formatierung des Codes
  - Logische Strukturierung der Funktionalität
  - EVA-Prinzip bei der Bewegungslogik angewendet
    

## 14. Januar 2025

### Was wir gemacht haben:
- SSH Server Management System in Java entwickelt:
  - Benutzer-Management implementiert (erstellen, einloggen, auflisten)
  - Datei-Operationen programmiert (erstellen, bearbeiten, löschen)
  - Sicherheitsfeatures eingebaut (Rechteverwaltung, Input-Validierung)
  - Konsolenmenü für Benutzerinteraktion erstellt

### Was wir gelernt haben:
- SSH-Verbindungen in Java:
  - JSch Bibliothek für SSH-Kommunikation
  - Verbindungsaufbau und -management
  - Ausführung von Remote-Befehlen
  - Session-Handling und Authentifizierung

- Fortgeschrittene Java-Konzepte:
  - Exception-Handling für Netzwerkoperationen
  - Scanner für Benutzereingaben
  - Regex für Input-Validierung
  - String-Manipulation für Befehlsausführung

- Sicherheitsaspekte:
  - Benutzerrechte-Verwaltung (Admin/User)
  - Sichere Passwortvalidierung
  - Dateizugriffsrechte
  - Eingabeüberprüfung gegen Injection

- Best Practices:
  - Strukturierte Fehlerbehandlung
  - Benutzerfreundliche Menüführung
  - Klare Rückmeldungen an Benutzer
  - Modularer Code-Aufbau nach EVA-Prinzip

# 21. Januar 2025

## Was ich gemacht habe:
- An meinem eigenen Projekt gearbeitet: **Arcade in Java**  
  - Grundstruktur der Arcade-Anwendung erstellt  
  - Hauptmenü programmiert mit Auswahlmöglichkeiten für verschiedene Spiele  
  - Zwei Spiele integriert:  
    - **Snake**: Spielfeld-Logik implementiert, Bewegungssteuerung und Punktesystem  
    - **Pong**: Spielfeld erstellt, Spielregeln umgesetzt und Gewinnlogik programmiert  
  - Grafische Konsolenausgabe für eine ansprechende Darstellung entwickelt  
  - Fehlerbehebung und Optimierung bestehender Codeabschnitte  

## Was ich gelernt habe:
- **Projektstrukturierung**:  
  - Hauptprogramm als Einstiegspunkt und modulare Spiele-Integration  
  - Code in separate Klassen und Pakete aufgeteilt für Übersichtlichkeit  

- **Spielprogrammierung in Java**:  
  - Verwendung von Schleifen und Bedingungen für Spielabläufe  
  - Benutzerinteraktion über Tastatureingaben (Scanner)  
  - Speicherung und Verarbeitung von Spielzuständen  

- **Fortgeschrittene Java-Konzepte**:  
  - Enums für Spielstatus und Steuerung  
  - Dynamische Array- und Listennutzung  
  - Refactoring zur Wiederverwendung von Code  

- **Best Practices**:  
  - Modularer Aufbau (jedes Spiel in einer eigenen Klasse)  
  - Klare Trennung nach dem EVA-Prinzip:  
    - Eingabe: Spielerbewegungen und Optionen  
    - Verarbeitung: Spiellogik und Statusverwaltung  
    - Ausgabe: Grafische Darstellung des Spielfelds  
  - Regelmäßige Codeüberprüfung und Debugging für saubere Funktionalität  

## Nächste Schritte:
- Weitere Spiele integrieren (z. B. Pong oder Minesweeper)  
- Benutzerfreundlichkeit verbessern (z. B. Speichern von Highscores)  
- GUI-Umsetzung mit JavaFX für eine moderne Darstellung prüfen


## 28. Januar 2025

### Was wir gemacht haben:
- **Testfälle für unser SSH Server Management System erstellt**  
  - Fünf Happy-Path‐Testfälle mit klarer Struktur (Beschreibung, Schritte, erwartetes Ergebnis, tatsächliches Ergebnis) dokumentiert  
  - Fokus lag auf Benutzer‐ und Dateioperationen (z. B. Admin‐Benutzer anlegen, Datei erstellen/ändern/löschen)

- **Testumgebung eingerichtet**  
  - JUnit in unser Java‐Projekt integriert, um einzelne Methoden automatisiert zu testen  
  - Erste einfache Unit‐Tests für Datei‐ und Benutzerfunktionen geschrieben  
  - Manuelle Tests in der Konsole durchgeführt (Überprüfung der erwarteten Ausgaben und Fehlermeldungen)

- **Projektstruktur weiter verfeinert**  
  - Hauptklasse „SSHApp“ schlanker gehalten und Logik in separate Manager‐Klassen ausgelagert  
  - Aufbau einer Utility‐Klasse für wiederverwendbare Helfer‐Methoden

### Was wir gelernt haben:
- **Testfall‐Erstellung (E4)**  
  - Wichtigkeit einer klaren Trennung zwischen Beschreibung, Schritten und erwarteten Ergebnissen  
  - Dokumentation hilft beim schnellen Erkennen und Reproduzieren von Fehlern  
  - „Happy Path“ zuerst testen, um Basisfunktionalität zu sichern

- **Automatisiertes Testen mit JUnit**  
  - Vorbereitung der Testmethoden (Annotations wie `@Test`)  
  - Assertions (`assertEquals`, `assertTrue`, etc.) zur automatischen Prüfung der Ergebnisse  
  - Klares Reporting von Fehlern und Testfortschritt

- **Verbesserung der Codequalität**  
  - Saubere Trennung der Verantwortlichkeiten (EVA‐Prinzip)  
  - Mehrere Dateien/Klassen für User‐Management, File‐Management und Netzwerklogik  
  - Lesbare Fehlermeldungen und Ausgaben für die Nutzer

ENTLICH FERTIG BITTE GÖNNEN SIE MIR(NEPOMUK CRHONEK) EINE ❤️6❤️
